/*
** ###################################################################
**     Processors:          QN9090
**                          QN9090
**
**     Compiler:            IAR ANSI C/C++ Compiler for ARM
**     Reference manual:    QN9090 User manual Rev.0.9  7 Nov 2016
**     Version:             rev. 1.1, 2016-11-25
**     Build:               b161227
**
**     Abstract:
**         Linker file for the IAR ANSI C/C++ Compiler for ARM
**
**     Copyright (c) 2016 Freescale Semiconductor, Inc.
**     Copyright 2016 - 2019 NXP
**     All rights reserved.
**
**     SPDX-License-Identifier: BSD-3-Clause
**
**     http:                 www.nxp.com
**     mail:                 support@nxp.com
**
** ###################################################################
*/

/******************* Map of Kinetis FLASH ***********************************

			             0x000a_0000    m_flash_end
    - - - +---------------+ - - - - - - - -
          |   _ _ _ _ _   |
          | Flash config  |
   8.5k   |   - - - - -   |
          |               |
          |  RESERVED     |  0x9de00
    - - - +---------------+ - - - - - - - -
          |               | m_fsl_prodInfo_end
    512   | Product Info  |
          |               | m_fsl_prodInfo_start       0x9dc00
    - - - +---------------+ - - - - - - - -
          |               | NV_STORAGE_START_ADDRESS
    32k   |  sNVM_region  |
          | - - - - - - - | --- NV_VIRTUAL_PAGE_BOUND
          |  fNVM_region  |
          |               | NV_STORAGE_END_ADDRESS
    - - - +---------------+ - - - - - - - -
          |               | INT_STORAGE_START
          |               |
          |               |
   ~311k  | OTAP Internal |
          |      Storage* |
          |               |
          |               |
          |               | INT_STORAGE_END = 0x48000
    - - - +---------------+ - - - - - - - -
          |               | m_text_end
          |               |
          |               |
  ~278k** |  Application  |
          |               |
          |               |
          |               | m_text_start
    - - - +---------------+ - - - - - - - -
          |               | m_bootFlags_end
 8 bytes  |  Boot Flags*  |
          |               | m_bootFlags_start
    - - - +---------------+ - - - - - - - -
          |   Interrupt   | m_interrupts_end
  0x120   |    Vectors    |
  bytes   |               | m_interrupts_start
    - - - +---------------+ - - - - - - - -
          |               | m_bootloader_end
          |               |
   10k    |  Bootloader*  |
          |               |
          |               | m_bootloader_start = m_flash_start
    - - - +---------------+ - - - - - - - -
             0x0000_0000

 * - These sections are optional for certain applications
 ** - Application will occupy all the free space available
*****************************************************************************/




/*** flash memory characteristics ***/
define exported symbol m_flash_start          = 0x00000000;
define exported symbol m_flash_end            = 0x0009FFFF;
define symbol          m_flash_size           = 0x000A0000;
define symbol          m_sector_size          = 512;       /* 512  */




/****************************************************
 *******         User Defines                 *******
 ****************************************************/
if (!isdefinedsymbol(gUseNVMLink_d)) {
  define symbol gUseNVMLink_d = 0;
  define symbol gNVMSectorCountLink_d = 0;
}
if(!isdefinedsymbol(gEraseNVMLink_d)) {
  define symbol gEraseNVMLink_d = 0;
}
if (!isdefinedsymbol(__ram_vector_table__)) {
  define symbol __ram_vector_table__ = 0;
}
if (!isdefinedsymbol(gUseBootloaderLink_d)) {
  define symbol gUseBootloaderLink_d = 0;
}
if (!isdefinedsymbol(gNVMSectorCountLink_d)) {
  define symbol gNVMSectorCountLink_d = 4;
}
if (!isdefinedsymbol(gUseInternalStorageLink_d)) {
  define symbol gUseInternalStorageLink_d = 0;
}
if (!isdefinedsymbol(__app_stated_size__)) {
  define symbol __app_stated_size__ = 0 ;
}
if (!isdefinedsymbol(__app_load_address__)) {
  define symbol __app_load_address__ = 0 ;
}
/****************************************************
 ******          Flash regions sizes           ******
 ****************************************************/
define symbol m_bootloader_size         = (gUseBootloaderLink_d) ? 20 * m_sector_size : 0;
define symbol __vector_table_size__     = 0x120;
define symbol __ram_vector_table_size__ = (__ram_vector_table__) ? 0x120 : 0;
define symbol m_bootFlags_size          = (gUseBootloaderLink_d) ? 0x10 : 0x0;
define symbol NV_STORAGE_SIZE           = gNVMSectorCountLink_d * m_sector_size;
define symbol m_reserved_flash_size     = 3 * m_sector_size;
define symbol m_fsl_prodInfo_size       = m_sector_size;
define symbol m_app_size                = (__app_stated_size__) ? __app_stated_size__ : 0x48000;

/****************************************************
 ******        Flash Regions, low to high      ******
 ****************************************************/
define symbol m_bootloader_start        = m_flash_start;
define symbol m_bootloader_end          = (m_bootloader_size > 0) ? (m_bootloader_start + m_bootloader_size - 1) : m_bootloader_start;
define symbol m_interrupts_start        = m_bootloader_size;
define symbol m_interrupts_end          = m_interrupts_start + __vector_table_size__ - 1;
define symbol m_bootFlags_start         = m_interrupts_end + 1;
define symbol m_bootFlags_end           = m_bootFlags_start + m_bootFlags_size - 1;
define symbol m_text_start              = m_bootFlags_end + 1;
define symbol m_app_start               = (__app_load_address__) ? __app_load_address__ : 0x0;
define symbol m_app_end                 = m_app_start + m_app_size - 1;

/****************************************************
 *****        Flash Regions, high to low       ******
 ****************************************************/
define symbol m_fsl_prodInfo_end                = m_flash_size - 17 * m_sector_size - 1;
define symbol  m_fsl_prodInfo_start             = m_fsl_prodInfo_end - m_fsl_prodInfo_size + 1;
define exported symbol NV_STORAGE_START_ADDRESS = m_fsl_prodInfo_start - 1;
define exported symbol NV_STORAGE_END_ADDRESS   = NV_STORAGE_START_ADDRESS - NV_STORAGE_SIZE + 1;
define exported symbol INT_STORAGE_START        = NV_STORAGE_END_ADDRESS - 1;
if (gUseInternalStorageLink_d){
  define exported symbol INT_STORAGE_END  = m_app_end + 1;
  define exported symbol INT_STORAGE_SIZE = INT_STORAGE_START - INT_STORAGE_END + 1;
}else{
  define exported symbol INT_STORAGE_END  = INT_STORAGE_START + 1;
  define exported symbol INT_STORAGE_SIZE = 0;
}
define symbol m_text_end                = INT_STORAGE_END - 1;


/* Exported Defines */
define exported symbol NV_STORAGE_SECTOR_SIZE        = m_sector_size;
define exported symbol NV_STORAGE_MAX_SECTORS        = gNVMSectorCountLink_d;
define exported symbol __BootFlags_Start__           = m_bootFlags_start;
define symbol NV_VIRTUAL_PAGE_BOUND                  = NV_STORAGE_START_ADDRESS - (NV_STORAGE_SIZE / 2);
define exported symbol INT_STORAGE_SECTOR_SIZE       = m_sector_size;
define exported symbol FREESCALE_PROD_DATA_BASE_ADDR = m_fsl_prodInfo_start;
define exported symbol __nv_storage_start_address   = NV_STORAGE_END_ADDRESS;
define exported symbol __nv_storage_end_address     = NV_STORAGE_START_ADDRESS;

/*********************
 * RAM memory config *
 *********************/
define symbol rom_bootloader_ram_used  = 0x400; // Reserved RAM for ROM Bootloader
define symbol m_interrupts_ram_start   = 0x04000000 + rom_bootloader_ram_used;
define symbol m_interrupts_ram_end     = m_interrupts_ram_start + __vector_table_size__ - 1;
define symbol m_data_start             = m_interrupts_ram_end + 1;
define symbol m_data_end               = 0x04016000;
define symbol m_data1_start            = 0x4020000;
define symbol m_data1_end              = 0x4030000;
define symbol _BOOT_RESUME_STACK_SIZE  = 1024;

/* RAM memory sizes */
if (isdefinedsymbol(__stack_size__)) {
  define symbol __stack_size__ = __stack_size__;
} else {
  define symbol __stack_size__ = 0x0800;
}
if (isdefinedsymbol(__heap_size__)) {
  define symbol __size_heap__   = __heap_size__;
} else {
  define symbol __size_heap__   = 0x0000;
}

/* Exported Defines */
define exported symbol __VECTOR_TABLE  = m_interrupts_start;
define exported symbol __VECTOR_RAM    = isdefinedsymbol(__ram_vector_table__) ? m_interrupts_ram_start : m_interrupts_start;
define exported symbol __RAM_VECTOR_TABLE_SIZE = __ram_vector_table_size__;
define exported symbol _RAM_START_     = m_data_start;
define exported symbol _RAM_END_       = m_data_end;

define exported symbol __mac_buffer_base            = m_data_start;
define exported symbol __base_RAM0                   = 0x4000400;

/*******************************************
 * Define the limits of the memory regions *
 *******************************************/
define memory mem with size = 4G;

//Flash
define region m_interrupts_region     = mem:[from m_interrupts_start to m_interrupts_end];
define region TEXT_region             = mem:[from m_text_start to m_text_end];
if (gUseInternalStorageLink_d) {
  define region BootFlags_region      = mem:[from m_bootFlags_start   to  m_bootFlags_end];
  define region InternalStorage       = mem:[from INT_STORAGE_END to INT_STORAGE_START];
}

//RAM
define region m_interrupts_ram_region = mem:[from m_interrupts_ram_start to m_interrupts_ram_end];
define region m_ll_exchange_mem_region = mem:[from _RAM_START_ to _RAM_START_ + 0x2800 -1];
define region DATA_region              = mem:[from _RAM_START_ + 0x2800  to m_data_end - 0x1000 -1];
define region m_boot_resume_mem_region = mem:[from m_data_end - 0x1000  to  m_data_end - 32 ];
define region DATA1_region             = mem:[from m_data1_start  to m_data1_end];
define exported symbol _end_fw_retention       = m_data_end - 0x1000;
define exported symbol _end_boot_resume_stack  = m_data_end - 32;

define block CSTACK    with alignment = 8, size = __stack_size__   { };
define block HEAP      with alignment = 8, size = __size_heap__     { };
define block RW        { readwrite };
define block ZI        { zi };

initialize by copy { readwrite, section .textrw };
if (isdefinedsymbol(__USE_DLIB_PERTHREAD))
{
  /* Required in a multi-threaded application */
  initialize by copy with packing = none { section __DLIB_PERTHREAD };
}
do not initialize  { section .noinit };

place in m_interrupts_region         { readonly section .intvec };
place in TEXT_region                 { readonly };

place in DATA_region                 { block RW };
place in DATA_region                 { block ZI };
place in DATA_region                 { last block HEAP };
place in m_ll_exchange_mem_region    { section .bss.ll_exchange_mem };
place in m_boot_resume_mem_region    { section .boot_resume_stack };
place in m_boot_resume_mem_region    { block CSTACK };

place in m_interrupts_ram_region     { section m_interrupts_ram };

if (gUseInternalStorageLink_d) {
  place in BootFlags_region          { readonly section BootloaderFlags };
}